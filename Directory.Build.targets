<Project>
  <!-- Properties which should be set after the project has been evaluated -->
  <PropertyGroup>
    <RuntimeFrameworkVersion Condition=" '$(TargetFramework)' == 'netcoreapp3.0' ">$(MicrosoftNETCoreAppPackageVersion)</RuntimeFrameworkVersion>
  </PropertyGroup>

  <!-- Properties which should be set after the project has been evaluated -->
  <PropertyGroup Condition=" '$(MSBuildProjectExtension)' == '.csproj' ">
    <PackageId Condition=" '$(PackageId)' == '' ">$(AssemblyName)</PackageId>
    <Description Condition=" '$(Description)' == ''">$(PackageId)</Description>
    <IsPackable Condition="'$(IsPackable)' == '' AND ( '$(IsUnitTestProject)' == 'true' OR '$(IsTestAssetProject)' == 'true' OR '$(IsBenchmarkProject)' == 'true' OR '$(IsSampleProject)' == 'true' ) ">false</IsPackable>
    <IsPackable Condition="'$(IsPackable)' == '' ">true</IsPackable>
  </PropertyGroup>

  <Import Project="eng\Baseline.Designer.props" />

  <PropertyGroup Condition=" '$(IsPackable)' != 'false' AND '$(IsServicingBuild)' == 'true' ">
    <IsPackable>$(PackagesInPatch.Contains(' $(PackageId);'))</IsPackable>
  </PropertyGroup>

  <PropertyGroup Condition=" '$(IsPackable)' == 'true' AND '$(BaselinePackageVersion)' != '' AND '$(IsServicingBuild)' == 'true' ">
    <!-- This keeps assembly versions consistent across patches. If a package is not included in a patch, its assembly version should stay at the baseline. -->
    <AssemblyVersion>$(BaselinePackageVersion).0</AssemblyVersion>
    <!--
      Ideally, we would also set the project version to match the baseline in case NuGet turns a ProjectReference into a nuspec depenendency, but
      NuGet does not currently handle conflicts between packages and projects which have the same package id/version.

      See https://github.com/NuGet/Home/issues/6795
    -->
    <!-- <Version>$(BaselinePackageVersion)</Version> -->
    <!-- <PackageVersion>$(BaselinePackageVersion)</PackageVersion> -->
  </PropertyGroup>

  <PropertyGroup>
    <!-- Implementation projects are the projects which produce nuget packages or shipping assemblies. -->
    <IsImplementationProject Condition=" '$(IsImplementationProject)' == '' AND '$(IsTestAssetProject)' != 'true' AND '$(IsUnitTestProject)' != 'true' AND '$(IsBenchmarkProject)' != 'true' AND '$(IsSampleProject)' != 'true' ">true</IsImplementationProject>
    <!-- This determines whether a project is available as a <Reference> to other projects in this repo. -->
    <IsProjectReferenceProvider Condition=" '$(IsProjectReferenceProvider)' == '' AND '$(IsImplementationProject)' == 'true' AND '$(PackAsTool)' != 'true' ">true</IsProjectReferenceProvider>
  </PropertyGroup>

  <Target Name="GenerateReferenceSource" DependsOnTargets="ResolveAssemblyReferences">
    <PropertyGroup>
      <_RefSourceOutputPath>$(MSBuildProjectDirectory)/../ref/</_RefSourceOutputPath>
      <_RefSourceFileOutputPath>$(_RefSourceOutputPath)$(AssemblyName).cs</_RefSourceFileOutputPath>
      <_RefProjectFileOutputPath>$(_RefSourceOutputPath)$(AssemblyName).csproj</_RefProjectFileOutputPath>
      <_ExcludeAPIList>$(RepositoryEngineeringDir)DefaultGenApiDocIds.txt</_ExcludeAPIList>
    </PropertyGroup>
    <ItemGroup>
      <_ReferenceDirectoriesWithDuplicates Include="@(ReferencePath->'%(RootDir)%(Directory)'->TrimEnd('\'))" />
      <_ReferencePathDirectories Include="%(_ReferenceDirectoriesWithDuplicates.Identity)" />
    </ItemGroup>

    <PropertyGroup>
      <_GenAPICommand Condition="'$(MSBuildRuntimeType)' == 'core'">$(ToolHostCmd) --roll-forward-on-no-candidate-fx 2 "$(_GenAPIPath)"</_GenAPICommand>
      <_GenAPICmd>$(_GenAPICommand)</_GenAPICmd>
      <_GenAPICmd>$(_GenAPICmd) "$(OutputPath)\$(AssemblyName).dll"</_GenAPICmd>
      <_GenAPICmd>$(_GenAPICmd) --lib-path "@(_ReferencePathDirectories)"</_GenAPICmd>
      <_GenAPICmd>$(_GenAPICmd) --out "$(_RefSourceFileOutputPath)"</_GenAPICmd>
    </PropertyGroup>

    <MakeDir Directories="$(_RefSourceOutputPath)" />
    <Exec Command="$(_GenAPICmd)" />
    <Message Text="Generated reference assembly source code: $(_RefSourceFileOutputPath)" />

    <ItemGroup>
      <_ReferencedProjectPaths
        Include="%(ReferencePath.ProjectPath)"
        ProjectName="$([System.IO.Path]::GetFileName('%(ReferencePath.ProjectPath)'))"
        RefLocation="$([System.IO.Path]::GetFullPath('%(ReferencePath.ProjectPath)/../../ref'))" Condition="'%(ReferencePath.ProjectPath)' != ''" />
      <_ReferencedProjects Include="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory), '%(_ReferencedProjectPaths.RefLocation)/%(_ReferencedProjectPaths.ProjectName)'))" />
    </ItemGroup>
    <ItemGroup>
      <_ReferencedProjectsNormalized Include="$([System.String]::new('%(_ReferencedProjects)').Replace('/','\'))"/>
    </ItemGroup>

    <PropertyGroup>
      <ProjectListFile>$(MSBuildThisFileDirectory)..\eng\ProjectReferences.props</ProjectListFile>
      <ProjectListContent><![CDATA[
<!-- This file is automatically generated. -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>$(TargetFramework)</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    @(_ReferencedProjects->'<ProjectReference Include="%(Identity)"  />', '%0A    ')
  </ItemGroup>
</Project>
]]></ProjectListContent>
    </PropertyGroup>

    <!-- Workaround https://github.com/Microsoft/msbuild/issues/1024 -->
    <WriteLinesToFile Condition="'$(OS)' == 'Windows_NT'"
                      File="$(_RefProjectFileOutputPath)" Lines="$([MSBuild]::Escape($(ProjectListContent)))" Overwrite="true" />
    <Exec Condition="'$(OS)' != 'Windows_NT'"
          Command="echo '$(ProjectListContent.Replace('\t','\\t'))' > $(_RefProjectFileOutputPath)" />


  </Target>

  <Import Project="eng\targets\Packaging.targets" Condition=" '$(MSBuildProjectExtension)' == '.csproj' " />
  <Import Project="eng\targets\ResolveReferences.targets" Condition=" '$(DisableReferenceRestrictions)' != 'true' AND '$(MSBuildProjectExtension)' == '.csproj' " />
  <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk" />
  <Import Project="eng\Workarounds.AfterArcade.targets" />

  <Import Project="eng\targets\Npm.Common.targets"  Condition="'$(MSBuildProjectExtension)' == '.npmproj'" />
  <Import Project="eng\targets\ref.targets"  Condition="$(BuildDefinition.EndsWith('.ref.csproj'))" />
</Project>
